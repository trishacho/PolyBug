{
  "null_reference1": {
    "language": "csharp",
    "buggy_code": "private bool InstallSourceKnown(string url)\n{\n    var pieces = url.Split('/');\n    if (pieces.Length < 4)\n        return false;\n    var author = pieces[3];\n    var acceptedSource = \"https://github.com\";\n    var constructedUrlPart = string.Format(\"{0}/{1}/\", acceptedSource, author);\n\n    return url.StartsWith(acceptedSource) &&\n           Context.API.GetAllPlugins().Any(x => x.Metadata.Website.StartsWith(constructedUrlPart));\n}",
  "supporting_classes": "public class PluginMetadata\n{\n    public string Website { get; set; }\n}\n\npublic class PluginPair\n{\n    public PluginMetadata Metadata { get; set; }\n}\n\npublic class IPublicAPI\n{\n    private readonly List<PluginPair> _plugins;\n\n    public IPublicAPI(List<PluginPair> plugins)\n    {\n        _plugins = plugins;\n    }\n\n    public List<PluginPair> GetAllPlugins()\n    {\n        return _plugins;\n    }\n}\n\npublic class PluginInitContext\n{\n    public IPublicAPI API { get; set; }\n}\n\npublic class PluginInstaller\n{\n    public PluginInitContext Context { get; set; }\n\n    {buggy_code}\n}",
    "test_logic": "var plugins = new List<PluginPair>\n{\n    new PluginPair { Metadata = new PluginMetadata { Website = null } }\n};\n\nvar testAPI = new IPublicAPI(plugins);\nvar testContext = new PluginInitContext { API = testAPI };\nvar installer = new PluginInstaller { Context = testContext };\n\nstring url = \"https://github.com/authorX/pluginRepo\";\n\nbool result = installer.InstallSourceKnown(url);\nConsole.WriteLine(\"Test result: \" + (result == false ? \"Null_reference 1 passed\" : \"Null_reference 1 failed\"));",
    "fixed_code": "public bool InstallSourceKnown(string url)\n{\n    var pieces = url.Split('/');\n    if (pieces.Length < 4)\n        return false;\n    var author = pieces[3];\n    var acceptedSource = \"https://github.com\";\n    var constructedUrlPart = string.Format(\"{0}/{1}/\", acceptedSource, author);\n\n    return url.StartsWith(acceptedSource) &&\n        Context.API.GetAllPlugins().Any(x =>\n            !string.IsNullOrEmpty(x.Metadata.Website) &&\n            x.Metadata.Website.StartsWith(constructedUrlPart));\n}"
},
  "null_reference2": {
    "language": "csharp",
    "buggy_code": "public static async Task CreateRelease(GitHubReleaseSettings settings)\n{\n    var client = CreateGitHubClient(settings.Token!, settings.BaseUrl!);\n\n    var existingReleases = await client.Repository.GetAll(settings.RepositoryOwner!, settings.RepositoryName!);\n    if (existingReleases.Any(x => x.TagName == settings.Tag))\n        return;\n\n    var newRelease = new NewRelease(settings.Tag!)\n    {\n        TargetCommitish = settings.TargetCommitish,\n        Name = settings.Name,\n        Body = settings.Body,\n        Draft = settings.Draft ?? false,\n        Prerelease = settings.PreRelease ?? false,\n        GenerateReleaseNotes = settings.GenerateReleaseNotes ?? false\n    };\n\n    var release = await client.Repository.Create(settings.RepositoryOwner!, settings.RepositoryName!, newRelease);\n\n    if (settings.ArtifactPaths.Count>0)\n    {\n        foreach (var path in settings.ArtifactPaths)\n        {\n            await using var file = File.OpenRead(path);\n            var asset = new ReleaseAssetUpload\n            {\n                FileName = Path.GetFileName(path),\n                ContentType = \"application/octet-stream\",\n                RawData = file\n            };\n            await client.Repository.UploadAsset(release, asset);\n        }\n    }\n}",
    "supporting_classes": "#nullable enable\n#pragma warning disable CS8618\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\n\npublic class ReadOnlyList<T> : List<T> { }\n\npublic class GitHubReleaseSettings\n{\n    public string? Token { get; set; }\n    public string? BaseUrl { get; set; }\n    public string? RepositoryOwner { get; set; }\n    public string? RepositoryName { get; set; }\n    public string? Tag { get; set; }\n    public string? Name { get; set; }\n    public string? TargetCommitish { get; set; }\n    public string? Body { get; set; }\n    public bool? Draft { get; set; }\n    public bool? PreRelease { get; set; }\n    public bool? GenerateReleaseNotes { get; set; }\n    public ReadOnlyList<string>? ArtifactPaths { get; set; }\n}\n\npublic class NewRelease\n{\n    public NewRelease(string tag) => Tag = tag;\n    public string Tag { get; }\n    public string? TargetCommitish { get; set; }\n    public string? Name { get; set; }\n    public string? Body { get; set; }\n    public bool Draft { get; set; }\n    public bool Prerelease { get; set; }\n    public bool GenerateReleaseNotes { get; set; }\n}\n\npublic class Release\n{\n    public string? Name { get; set; }\n    public string? TagName { get; set; }\n    public string? TargetCommitish { get; set; }\n    public string? Body { get; set; }\n    public bool Draft { get; set; }\n    public bool Prerelease { get; set; }\n}\n\npublic class ReleaseAssetUpload\n{\n    public string? FileName { get; set; }\n    public string? ContentType { get; set; }\n    public Stream? RawData { get; set; }\n}\n\npublic class ReleaseAsset\n{\n    public string? Name { get; set; }\n}\n\npublic interface GitHubClient\n{\n    ReleaseClient Repository { get; }\n}\n\npublic interface ReleaseClient\n{\n    Task<ReadOnlyList<Release>> GetAll(string owner, string repo);\n    Task<Release> Create(string owner, string repo, NewRelease release);\n    Task<ReleaseAsset> UploadAsset(Release release, ReleaseAssetUpload upload);\n}\n\npublic class FakeGitHubClient : GitHubClient\n{\n    public ReleaseClient Repository => new FakeReleaseClient();\n}\n\npublic class FakeReleaseClient : ReleaseClient\n{\n    public Task<ReadOnlyList<Release>> GetAll(string owner, string repo)\n    {\n        return Task.FromResult<ReadOnlyList<Release>>(new ReadOnlyList<Release>());\n    }\n\n    public Task<Release> Create(string owner, string repo, NewRelease release)\n    {\n        return Task.FromResult(new Release\n        {\n            Name = release.Name,\n            TagName = release.Tag,\n            TargetCommitish = release.TargetCommitish,\n            Body = release.Body,\n            Draft = release.Draft,\n            Prerelease = release.Prerelease\n        });\n    }\n\n    public Task<ReleaseAsset> UploadAsset(Release release, ReleaseAssetUpload upload)\n    {\n        return Task.FromResult(new ReleaseAsset { Name = upload.FileName });\n    }\n}\n\npublic static class GitHubReleaseCreator\n{\n    public static Func<string, string, GitHubClient> CreateGitHubClient = (token, baseUrl) => new FakeGitHubClient();\n\n    {buggy_code}\n}",
    "test_logic": "await GitHubReleaseCreator.CreateRelease(new GitHubReleaseSettings\n{\n    Token = \"fake-token\",\n    BaseUrl = \"https://api.github.com\",\n    RepositoryOwner = \"owner\",\n    RepositoryName = \"repo\",\n    Tag = \"v1.0.0\",\n    ArtifactPaths = null,\n    Draft = false,\n    PreRelease = false,\n    GenerateReleaseNotes = false,\n    Name = \"Release v1.0.0\",\n    TargetCommitish = \"main\",\n    Body = \"Release notes\"\n});\n\nConsole.WriteLine(\"Null_reference 2 passed\");",
    "fixed_code": "public static async Task CreateRelease(GitHubReleaseSettings settings)\n{\n    var client = CreateGitHubClient(settings.Token!, settings.BaseUrl!);\n\n    var existingReleases = await client.Repository.GetAll(settings.RepositoryOwner!, settings.RepositoryName!);\n    if (existingReleases.Any(x => x.TagName == settings.Tag))\n        return;\n\n    var newRelease = new NewRelease(settings.Tag!)\n    {\n        TargetCommitish = settings.TargetCommitish,\n        Name = settings.Name,\n        Body = settings.Body,\n        Draft = settings.Draft ?? false,\n        Prerelease = settings.PreRelease ?? false,\n        GenerateReleaseNotes = settings.GenerateReleaseNotes ?? false\n    };\n\n    var release = await client.Repository.Create(settings.RepositoryOwner!, settings.RepositoryName!, newRelease);\n\n    if (settings.ArtifactPaths is { Count: > 0 })\n    {\n        foreach (var path in settings.ArtifactPaths)\n        {\n            await using var file = File.OpenRead(path);\n            var asset = new ReleaseAssetUpload\n            {\n                FileName = Path.GetFileName(path),\n                ContentType = \"application/octet-stream\",\n                RawData = file\n            };\n            await client.Repository.UploadAsset(release, asset);\n        }\n    }\n}"
  },
  "null_reference3": {
    "language": "csharp",
    "buggy_code": "public void AddRecord(RetryRecord record)\n{\n\n    if (record.Headers.TryGetLastBytes(\"Retry-Key\", out byte[] previousGuid))\n    {\n        string oldGuidKey = Encoding.UTF8.GetString(previousGuid);\n        record.Headers.Remove(oldGuidKey);\n        records.Remove(oldGuidKey);\n    }\n\n    var newKey = Guid.NewGuid().ToString();\n    record.Headers.AddOrUpdate(\"Retry-Key\", Encoding.UTF8.GetBytes(newKey));\n    records.Add(newKey, record);\n    queueRecords.Enqueue(record);\n}",
    "supporting_classes": "#nullable enable\n#pragma warning disable CS8618\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic class Headers : Dictionary<string, List<byte[]>>\n{\n    public bool TryGetLastBytes(string key, out byte[] value)\n    {\n        value = null!;\n        if (TryGetValue(key, out var list) && list.Count > 0)\n        {\n            value = list[^1];\n            return true;\n        }\n        return false;\n    }\n\n    public void AddOrUpdate(string key, byte[] value)\n    {\n        if (!TryGetValue(key, out var list))\n        {\n            list = new List<byte[]>();\n            this[key] = list;\n        }\n        list.Add(value);\n    }\n\n    public void Remove(string key)\n    {\n        Remove(key);\n    }\n}\n\npublic class RetryRecord\n{\n    public Headers? Headers { get; set; }\n}\n\npublic class RetryHandler\n{\n    private readonly Dictionary<string, RetryRecord> records = new();\n    private readonly Queue<RetryRecord> queueRecords = new();\n\n    {buggy_code}\n}",
    "test_logic": "var handler = new RetryHandler();\nvar record = new RetryRecord { Headers = null }; // simulate null Headers\n\nhandler.AddRecord(record);\nConsole.WriteLine(\"null_reference3 passed\");",
    "fixed_code": "public void AddRecord(RetryRecord record)\n{\n    record.Headers ??= new Headers();\n\n    if (record.Headers.TryGetLastBytes(\"Retry-Key\", out byte[] previousGuid))\n    {\n        string oldGuidKey = Encoding.UTF8.GetString(previousGuid);\n        record.Headers.Remove(oldGuidKey);\n        records.Remove(oldGuidKey);\n    }\n\n    var newKey = Guid.NewGuid().ToString();\n    record.Headers.AddOrUpdate(\"Retry-Key\", Encoding.UTF8.GetBytes(newKey));\n    records.Add(newKey, record);\n    queueRecords.Enqueue(record);\n}"
  },
  "null_reference4": {
    "language": "csharp",
    "buggy_code": "public Branch getBetaBranch(Config cfg)\n{\n    // Try to find the HEAD of the \n    foreach (var remote in repo.Network.Remotes)\n    {\n        string expectedDefaultRefName = $\"refs/remotes/{remote.Name}/HEAD\";\n        var defaultRef = repo.Refs.FirstOrDefault(r => r.CanonicalName == expectedDefaultRefName) as SymbolicReference;\n        if (defaultRef != null)\n        {\n            var branch = repo.Branches.FirstOrDefault(b => b.CanonicalName == defaultRef.TargetIdentifier);\n            log.Debug(\"Determined beta branch to be '{0}' by looking at the HEAD of the remote '{1}'.\", branch.GetShortName(), remote.Name);\n            if (branch != null)\n            {\n                return branch;\n            }\n        }\n    }\n\n    Branch? defaultBranch = cfg.BetaBranchRegexes.Select(rx => repo.Branches.FirstOrDefault(b => rx.IsMatch(b.GetShortName()))).FirstOrDefault(b => b != null);\n    if (defaultBranch == null)\n    {\n        StringBuilder error = new StringBuilder(\"Unable to determine the default branch. No branch matching \");\n        error.Append(String.Join(\", \", cfg.BetaBranchPatterns.SkipLastN(1).Select(p => $\"'{p}'\")));\n        if (cfg.BetaBranchPatterns.Count > 1)\n            error.Append(\" or \");\n        error.Append($\"'{cfg.BetaBranchPatterns.Last()}' could be found. Searched {repo.Branches.Count()} branches.\");\n        log.Error(error.ToString());\n        log.Debug(\"Branches:\");\n        int c = 0;\n        StringBuilder line = new StringBuilder();\n        foreach (Branch item in repo.Branches.OrderBy(b => b.FriendlyName))\n        {\n            string bName = item.FriendlyName;\n            if (bName.Length > 25)\n                bName = bName.Substring(0, 25 - 3) + \"...\";\n            line.AppendFormat(\"{0,-26}\", bName);\n            c++;\n            if (c == 4)\n            {\n                log.Debug(line.ToString());\n                c = 0;\n                line.Clear();\n            }\n        }\n        if (line.Length > 0)\n            log.Debug(line.ToString());\n        throw new NotSupportedException(error.ToString());\n    }\n    log.Debug(\"Determined beta branch to be '{0}' using regular expression match.\", defaultBranch.GetShortName());\n    return defaultBranch;\n}",
    "supporting_classes": "#nullable enable\n#pragma warning disable CS8618\n\nusing System;\nusing System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\npublic class Config\n{\n    public List<Regex> BetaBranchRegexes { get; set; } = new();\n    public List<string> BetaBranchPatterns { get; set; } = new();\n}\n\npublic class Branch\n{\n    public string CanonicalName { get; set; }\n    public string FriendlyName { get; set; }\n    public string GetShortName() => FriendlyName;\n}\n\npublic class SymbolicReference\n{\n    public string TargetIdentifier { get; set; }\n    public string CanonicalName { get; set; }\n}\n\npublic class Remote\n{\n    public string Name { get; set; }\n}\n\npublic class RepoNetwork\n{\n    public List<Remote> Remotes { get; set; } = new();\n}\n\npublic class Repo\n{\n    public RepoNetwork Network { get; set; } = new();\n    public List<Branch> Branches { get; set; } = new();\n    public List<SymbolicReference> Refs { get; set; } = new();\n}\n\npublic class Logger\n{\n    public void Debug(string msg, params object[] args) => Console.WriteLine(\"DEBUG: \" + string.Format(msg, args));\n    public void Error(string msg) => Console.WriteLine(\"ERROR: \" + msg);\n}\n\npublic class BranchResolver\n{\n    public Repo repo = new();\n    public Logger log = new();\n\n    {buggy_code}\n}",
    "test_logic": "var resolver = new BranchResolver();\nresolver.repo.Network.Remotes.Add(new Remote { Name = \"origin\" });\nresolver.repo.Refs.Add(new SymbolicReference\n{\n    CanonicalName = \"refs/remotes/origin/HEAD\",\n    TargetIdentifier = \"refs/remotes/origin/main\"\n});\n\nresolver.repo.Branches.Add(new Branch { CanonicalName = \"refs/remotes/origin/beta\", FriendlyName = \"origin/beta\" });\n\nvar cfg = new Config();\ncfg.BetaBranchRegexes.Add(new Regex(\"beta\"));\ncfg.BetaBranchPatterns.Add(\"beta\");\n\nvar result = resolver.getBetaBranch(cfg);\nConsole.WriteLine(\"null_reference4 passed\");",
    "fixed_code": "public Branch getBetaBranch(Config cfg)\n{\n    foreach (var remote in repo.Network.Remotes)\n    {\n        string expectedDefaultRefName = $\"refs/remotes/{remote.Name}/HEAD\";\n        var defaultRef = repo.Refs.FirstOrDefault(r => r.CanonicalName == expectedDefaultRefName) as SymbolicReference;\n        if (defaultRef != null)\n        {\n            var branch = repo.Branches.FirstOrDefault(b => b.CanonicalName == defaultRef.TargetIdentifier);\n            if (branch != null)\n            {\n                log.Debug(\"Determined beta branch to be '{0}' by looking at the HEAD of the remote '{1}'.\", branch.GetShortName(), remote.Name);\n                return branch;\n            }\n        }\n    }\n\n    Branch? defaultBranch = cfg.BetaBranchRegexes.Select(rx => repo.Branches.FirstOrDefault(b => rx.IsMatch(b.GetShortName()))).FirstOrDefault(b => b != null);\n    if (defaultBranch == null)\n    {\n        StringBuilder error = new StringBuilder(\"Unable to determine the default branch. No branch matching \");\n        error.Append(String.Join(\", \", cfg.BetaBranchPatterns.SkipLast(1).Select(p => $\"'{p}'\")));\n        if (cfg.BetaBranchPatterns.Count > 1)\n            error.Append(\" or \");\n        error.Append($\"'{cfg.BetaBranchPatterns.Last()}' could be found. Searched {repo.Branches.Count()} branches.\");\n        log.Error(error.ToString());\n        log.Debug(\"Branches:\");\n        int c = 0;\n        StringBuilder line = new StringBuilder();\n        foreach (Branch item in repo.Branches.OrderBy(b => b.FriendlyName))\n        {\n            string bName = item.FriendlyName;\n            if (bName.Length > 25)\n                bName = bName.Substring(0, 22) + \"...\";\n            line.AppendFormat(\"{0,-26}\", bName);\n            c++;\n            if (c == 4)\n            {\n                log.Debug(line.ToString());\n                c = 0;\n                line.Clear();\n            }\n        }\n        if (line.Length > 0)\n            log.Debug(line.ToString());\n        throw new NotSupportedException(error.ToString());\n    }\n    log.Debug(\"Determined beta branch to be '{0}' using regular expression match.\", defaultBranch.GetShortName());\n    return defaultBranch;\n}"
  },
  "null_reference5": {
    "language": "csharp",
    "buggy_code": "private static byte GetInputCode(InputKey key, Controller c, string tech, string brand, SdlToDirectInput ctrl, bool globalAxis = false, bool trigger = false, bool digital = false)\n{\n    bool revertAxis;\n    key = RevertedAxis(key, out revertAxis);\n\n    string esName = (c.Config[key].Name).ToString();\n\n    if (brand == \"nintendo\")\n    {\n        if (trigger && !digital)\n        {\n            if (key == InputKey.r2 || key == InputKey.l2)\n                return 0x05;\n        }\n    }\n    if (esName == null || !esToDinput.ContainsKey(esName))\n        return 0x00;\n    string dinputName = esToDinput[esName];\n    if (dinputName == null)\n        return 0x00;\n    if (!ctrl.ButtonMappings.ContainsKey(dinputName))\n        return 0x00;\n    return 0x10;\n}\n\nprivate static InputKey RevertedAxis(InputKey key, out bool revert)\n{\n    revert = false;\n    return key;\n}",
    "supporting_classes": "using System;\nusing System.Collections.Generic;\n\n#nullable enable\n#pragma warning disable CS8618\n\npublic enum InputKey { r2, l2, dummy }\n\npublic class KeyConfig\n{\n    public string Name { get; set; } = \"\";\n}\n\npublic class Controller\n{\n    public Dictionary<InputKey, KeyConfig?> Config { get; set; } = new();\n}\n\npublic class SdlToDirectInput\n{\n    public Dictionary<string, string> ButtonMappings { get; set; } = new();\n}\n\npublic static class Mapper\n{\n    public static Dictionary<string, string> esToDinput = new();\n\n    {buggy_code}\n}",
    "test_logic": "var controller = new Controller();\ncontroller.Config[InputKey.r2] = null; // Simulate null config\n\nvar ctrl = new SdlToDirectInput { ButtonMappings = new Dictionary<string, string>() };\nMapper.esToDinput.Clear();\n\nvar result = Mapper.GetInputCode(InputKey.r2, controller, \"any\", \"nintendo\", ctrl, trigger: true, digital: false);\nConsole.WriteLine(\"null_reference5 passed\");",
    "fixed_code": "public static byte GetInputCode(InputKey key, Controller c, string tech, string brand, SdlToDirectInput ctrl, bool globalAxis = false, bool trigger = false, bool digital = false)\n{\n    bool revertAxis;\n    key = RevertedAxis(key, out revertAxis);\n\n    var keyConfig = c.Config[key];\n    if (keyConfig == null)\n    {\n        return 0x00;\n    }\n    string esName = keyConfig.Name;\n\n    if (brand == \"nintendo\")\n    {\n        if (trigger && !digital)\n        {\n            if (key == InputKey.r2 || key == InputKey.l2)\n                return 0x05;\n        }\n    }\n    if (esName == null || !esToDinput.ContainsKey(esName))\n        return 0x00;\n    string dinputName = esToDinput[esName];\n    if (dinputName == null)\n        return 0x00;\n    if (!ctrl.ButtonMappings.ContainsKey(dinputName))\n        return 0x00;\n    return 0x10;\n}\n\nprivate static InputKey RevertedAxis(InputKey key, out bool revert)\n{\n    revert = false;\n    return key;\n}"
  },
  "null_reference6": {
    "language":"php",
    "buggy_code": "protected function initializeCfgValue($dfltVal, $dfltCacheKey) {\n    if (!isset(self::$mDefaultSeps) || !is_array(self::$mDefaultSeps)) {\n        self::$mDefaultSeps = [];\n    }\n\n    $cache = &self::$mDefaultSeps[$dfltCacheKey];\n\n    if (!isset($cache)) {\n        $cache = $this->getCfgSepText($dfltVal);\n        if ($cache === null) {\n            global $wgSrfgArraySepTextualFallbacks;\n            $cache = $wgSrfgArraySepTextualFallbacks[$dfltCacheKey];        }\n    }\n    return $cache;\n}",
    "fixed_code": "protected function initializeCfgValue($dfltVal, $dfltCacheKey) {\n    if (!isset(self::$mDefaultSeps) || !is_array(self::$mDefaultSeps)) {\n        self::$mDefaultSeps = [];\n    }\n\n    $cache = &self::$mDefaultSeps[$dfltCacheKey];\n\n    if (!isset($cache)) {\n        $cache = $this->getCfgSepText($dfltVal);\n        if ($cache === null) {\n            global $wgSrfgArraySepTextualFallbacks;\n            $cache = $wgSrfgArraySepTextualFallbacks[$dfltCacheKey] ?? '';        }\n    }\n    return $cache;\n}",
    "supporting_classes": "set_error_handler(function ($severity, $message, $file, $line) {\n    throw new ErrorException($message, 0, $severity, $file, $line);\n});\n\nclass TestClass {\n    private static $mDefaultSeps;\n\n    public function getCfgSepText($val) {\n        return null; // Simulate failure\n    }\n\n    {buggy_code}\n\n    public function test() {\n        return $this->initializeCfgValue('someVal', 'missingKey');\n    }\n}",
    "test_logic": "$wgSrfgArraySepTextualFallbacks = []; // Simulate missing key\n\n$obj = new class extends TestClass {\n    public function run() {\n        return $this->test();\n    }\n};\n\ntry {\n    $result = $obj->run();\n    echo \"null_reference6 passed\";\n} catch (Throwable $e) {\n    echo \"null_reference6 failed . \"\\n\";\n}"
  },
  "null_reference7": {
    "language": "javascript",
    "buggy_code": "const handleGetDirections = () => {\n  try {\n    trackEvent(\"Get Directions\", { selectedBuilding });\n    console.log(\"Event tracked\");\n  } catch (e) {\n    console.error(e);\n  }\n  setIsRoute(true);\n  setIsSearch(true);\n  setEnd(selectedBuilding.point);\n  setDestinationPosition(selectedBuilding.name);\n  setStart(location.coords);\n  setStartPosition(\"Your Location\");\n};",
    "fixed_code": "const handleGetDirections = () => {\n  try {\n    trackEvent(\"Get Directions\", { selectedBuilding });\n    console.log(\"Event tracked\");\n  } catch (e) {\n    console.error(e);\n  }\n  setIsRoute(true);\n  setIsSearch(true);\n  setEnd(selectedBuilding.point);\n  setDestinationPosition(selectedBuilding.name);\n  if (location != null) {\n    setStart(location.coords);\n  }\n  setStartPosition(\"Your Location\");\n};",
    "supporting_classes": "const selectedBuilding = {\n  name: \"Library\",\n  point: { lat: 123, lng: 456 }\n};\n\nlet called = [];\nfunction trackEvent(eventName, payload) {\n  called.push([\"trackEvent\", eventName, payload]);\n}\nfunction setIsRoute(v) { called.push([\"setIsRoute\", v]); }\nfunction setIsSearch(v) { called.push([\"setIsSearch\", v]); }\nfunction setEnd(point) { called.push([\"setEnd\", point]); }\nfunction setDestinationPosition(name) { called.push([\"setDestinationPosition\", name]); }\nfunction setStart(coords) { called.push([\"setStart\", coords]); }\nfunction setStartPosition(label) { called.push([\"setStartPosition\", label]); }\n\nlet location = null; // simulate null location\n\n{buggy_code}",
    "test_logic": "handleGetDirections();\nconsole.log(\"null_reference7 passed\");"
  },
  "null_reference8": {
    "language": "typescript",
    "buggy_code": "private _injectExtensions(editor: Document.IEditor): void {\n  const codeEditor = editor.getEditor()!;\n  if (codeEditor.isDisposed) {\n    return;\n  }\n\n  this._extensions.forEach(factory => {\n    const ext = factory.factory({\n      path: this._widgetAdapter.widget.context.path,\n      editor: editor,\n      widgetAdapter: this._widgetAdapter,\n      model: codeEditor.model,\n      inline: true\n    });\n    if (!ext) {\n      return;\n    }\n    codeEditor.injectExtension(ext.instance(codeEditor));\n  });\n}",
    "fixed_code": "private _injectExtensions(editor: Document.IEditor): void {\n  const codeEditor = editor.getEditor();\n  if (!codeEditor || codeEditor.isDisposed) {\n    return;\n  }\n\n  this._extensions.forEach(factory => {\n    const ext = factory.factory({\n      path: this._widgetAdapter.widget.context.path,\n      editor: editor,\n      widgetAdapter: this._widgetAdapter,\n      model: codeEditor.model,\n      inline: true\n    });\n    if (!ext) {\n      return;\n    }\n    codeEditor.injectExtension(ext.instance(codeEditor));\n  });\n}",
    "supporting_classes": "namespace Document {\n  export interface IEditor {\n    getEditor(): CodeEditor.IEditor | null;\n  }\n}\n\nnamespace CodeEditor {\n  export interface IEditor {\n    isDisposed: boolean;\n    model: any;\n    injectExtension(ext: any): void;\n  }\n}\n\nclass WidgetAdapter {\n  widget = {\n    context: {\n      path: 'fake-path'\n    }\n  };\n}\n\ninterface ExtensionFactory {\n  factory(config: any): { instance: (editor: CodeEditor.IEditor) => any } | null;\n}\n\nclass ExtensionInjector {\n  private _extensions: ExtensionFactory[] = [];\n  private _widgetAdapter = new WidgetAdapter();\n\n  public addExtension(factory: ExtensionFactory) {\n    this._extensions.push(factory);\n  }\n\n  {buggy_code}\n}",
    "test_logic": "const injector = new ExtensionInjector();\n\nconst fakeEditor: Document.IEditor = {\n  getEditor: () => null\n};\n\ninjector.addExtension({\n  factory: () => ({ instance: () => ({}) })\n});\n\ntry {\n  (injector as any)._injectExtensions(fakeEditor);\n  console.log(\"null_reference8 passed\");\n} catch (e) {\n  console.log(\"null_reference8 failed\");\n}"
  },
   "null_reference9": {
    "language": "javascript",
    "buggy_code": "function getUsers() {\n  this.loaders.users = true;\n  this.usersIds = null;\n  return this.privateDatabaseService\n    .getUsers(this.productId)\n    .then((users) => {\n      this.usersIds = users.sort((a, b) => a.localeCompare(b));\n      this.users = this.usersIds.map((id) => ({ id }));\n    })\n    .catch((err) => {\n      this.alerter.error(get(err, 'message', err), this.$scope.alerts.main);\n    })\n    .finally(() => {\n      if (isEmpty(this.usersIds)) {\n        this.loaders.users = false;\n      }\n    });\n}",
    "fixed_code": "function getUsers() {\n  this.loaders.users = true;\n  this.usersIds = null;\n  return this.privateDatabaseService\n    .getUsers(this.productId)\n    .then((users) => {\n      this.usersIds = users\n        .filter((user) => Boolean(user))\n        .sort((a, b) => a.localeCompare(b));\n      this.users = this.usersIds.map((id) => ({ id }));\n    })\n    .catch((err) => {\n      this.alerter.error(get(err, 'message', err), this.$scope.alerts.main);\n    })\n    .finally(() => {\n      if (isEmpty(this.usersIds)) {\n        this.loaders.users = false;\n      }\n    });\n}",
    "supporting_classes": "function get(path, fallback) {\n  return path || fallback;\n}\nfunction isEmpty(arr) {\n  return !arr || arr.length === 0;\n}\nconst called = [];\nconst mockContext = {\n  productId: 'abc123',\n  loaders: { users: false },\n  usersIds: [],\n  users: [],\n  alerter: {\n    error: (msg, alert) => called.push([\"error\", msg])\n  },\n  $scope: { alerts: { main: \"main-alert\" } },\n  privateDatabaseService: {\n    getUsers: () => Promise.resolve([\"bob\", null, \"alice\", undefined, \"carol\"])\n  },\n  getUsers: null\n};\nmockContext.getUsers = {buggy_code}.bind(mockContext);",
    "test_logic": "mockContext.getUsers().then(() => {\n  const idsOk = JSON.stringify(mockContext.usersIds) === JSON.stringify([\"alice\", \"bob\", \"carol\"]);\n  const usersOk = JSON.stringify(mockContext.users) === JSON.stringify([\n    { id: \"alice\" }, { id: \"bob\" }, { id: \"carol\" }\n  ]);\n  if (idsOk && usersOk) {\n    console.log(\"null_reference9 passed\");\n  } else {\n    console.log(\"null_reference9 failed\");\n  }\n});"

  },
   "null_reference10": {
    "language": "java",
    "buggy_code": "public void packetReceived(BasePacket packet) {\n    ERP1Message msg = (ERP1Message) packet;\n    EEPType localReceivingType = receivingEEPTypes.get(msg.getRORG());\n    EEP eep = EEPFactory.buildEEP(localReceivingType, msg);\n    System.out.println(\"Packet received\");\n    if (eep.isValid()) {\n        // Do something\n    }\n}",
    "fixed_code": "public void packetReceived(BasePacket packet) {\n    ERP1Message msg = (ERP1Message) packet;\n    EEPType localReceivingType = receivingEEPTypes.get(msg.getRORG());\n    if (localReceivingType == null) {\n        return;\n    }\n    EEP eep = EEPFactory.buildEEP(localReceivingType, msg);\n    System.out.println(\"Packet received\");\n    if (eep.isValid()) {\n        // Do something\n    }\n}",
    "supporting_classes": "interface BasePacket {}\ninterface ERP1Message extends BasePacket {\n    byte getRORG();\n}\ninterface EEPType {}\ninterface EEP {\n    boolean isValid();\n}\nclass EEPFactory {\n    public static EEP buildEEP(EEPType type, ERP1Message msg) {\n        if (type == null) {\n            throw new NullPointerException(\"EEPType is null\");\n        }\n        return new EEP() {\n            public boolean isValid() { return true; }\n        };\n    }\n}\nclass TestClass {\n    java.util.Map<Byte, EEPType> receivingEEPTypes = new java.util.HashMap<>();\n    {buggy_code}\n}",
    "test_logic": "class TestMain {\n    public static void main(String[] args) {\n        try {\n            TestClass testInstance = new TestClass();\n            ERP1Message msg = new ERP1Message() {\n                public byte getRORG() { return 0x01; }\n            };\n            // No entry added to receivingEEPTypes => should trigger null and fail in buggy version\n            testInstance.packetReceived(msg);\n            System.out.println(\"null_reference10 passed\");\n        } catch (Exception e) {\n            System.out.println(\"null_reference10 failed\");\n        }\n    }\n}"
  }
}
